// 1. Znajdujemy mosty - relacje między różnymi klastrami
MATCH (a:Stop)-[r:DRIVE]->(b:Stop)
WHERE a.communityId <> b.communityId
  AND r.dep_time IS NOT NULL 
  AND r.arr_time IS NOT NULL

// 2. Konwersja czasu "w locie" (String -> Integer)
// Rozbijamy "HH:MM:SS" i liczymy sekundy od północy
WITH a, b, r,
     split(r.dep_time, ':') AS d_parts,
     split(r.arr_time, ':') AS a_parts
WITH a, b, 
     (toInteger(d_parts[0]) * 3600 + toInteger(d_parts[1]) * 60 + toInteger(d_parts[2])) AS dep_seconds,
     (toInteger(a_parts[0]) * 3600 + toInteger(a_parts[1]) * 60 + toInteger(a_parts[2])) AS arr_seconds

// 3. Obliczamy średni czas przejazdu autobusu na tym odcinku
WITH a, b, avg(arr_seconds - dep_seconds) AS avg_bus_duration

// 4. Logika naprawcza (Sanity Check)
WITH a, b, 
     CASE 
        // Jeśli autobus jedzie < 30 sekund (lub 0), to spacer zajmie min. 5 minut (300s)
        WHEN avg_bus_duration < 30 THEN 300
        // W przeciwnym razie: czas autobusu * 5
        ELSE toInteger(avg_bus_duration * 5)
     END AS final_walk_time

// 5. Tworzymy lub aktualizujemy relację WALK
MERGE (a)-[w:WALK]->(b)
SET w.time_sec = final_walk_time,
    w.type = 'GENERATED_BRIDGE',
    w.distance_info = 'Czas wyliczony ze stringów. Bus: ' + toInteger(avg_bus_duration) + 's -> Walk: ' + final_walk_time + 's'

RETURN count(w) AS Liczba_Utworzonych_Mostow;